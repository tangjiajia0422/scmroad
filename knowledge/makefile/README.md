# Makefile

## Makefile基础

Makefile文件的基本格式很简单：
```bash
目标文件： 依赖文件1 依赖文件2 依赖文件3 。。。。
[tab]编译命令
```
Makefile 中可能有很多以上条目，他们共同组成了一个有向无回路图（DAG图），这样可以传递依赖。
make 命令会把 Makefile 文件的第一个目标文件作为默认目标，当执行 make 命令时，make 会考察这个目标文件的依赖关系，进行编译

## make的工作过程

1. 读取Makefile，根据make的选项查找Makefile
2. 初始化Makefile，将Makefile中的变量进行替换，如果Makefile中包含其他文件，则加载他
3. 解释规则，对其中的执行规则进行解析，推导隐藏规则，为目标建立关系链
4. 分析变更，根据依赖关系和时间戳，判断有木有变化。
5. 执行。

## 变量定义
### 常规法定义

A=content，等号两边可以有空格，和shell不一样

### 递归法定义

A=(B)，B=(C)，C=haha，那么当寻找A的定义的时候就会去找B，然后再找C，变量展开的时候就是当他被引用的时候，这种方法效率比较低，因为如果他引用了函数，那么每次展开都要调用函数，而且可能会出现无限递归（A=(B),B=(B),B=(A)）。

### 直接展开法定义

这个很容易理解，就像是c语言是按照顺序执行的，当变量定义的时候这个变量就已经展开了（如果他引用了变量A，引用的是他定义时候A的值），当被引用的时候就直接用他代表的字符串替代。但是他用的不是等号而是 := ,比如 A:=hello，A:=$(B)。

### 嵌套定义

A=B,B=haha,V=((A))类似于这种的V的值是haha

### 替换引用定义

替换后缀，有个例子很好 foo := a.o b.o c.o ,bar := $(foo:.o=.c),我们可以知道bar的值就是 a.c b.c c.c。

## 变量分类

### 预定义变量，当使用隐式规则的时候他会派上用场，常用的有以下几个：
```bash
CC       c编译器的名称（默认gcc？）
CPP      c预编译器名称（默认$(CC) -E）
CXX      c++编译器的名称(默认g++)
CFLAGS   c编译器选项,无默认值
CXXFLAGS c++编译器选项,无默认值
```

### 自动变量,常用有以下:
```bash
$@       表示当前规则中的完整目标文件名
$*       不包含扩展名的目标文件名
$<       当前规则中第一个依赖文件名
$^       当前规则所有文件列表
$%       当目标为库文件时,表示库文件名
```

### 环境变量

Makefile对环境变量是可见的,可以引用.

## 隐式规则

make会自己推导
