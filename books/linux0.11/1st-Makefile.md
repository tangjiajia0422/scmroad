# Linux 内核体系结构

## 操作系统组成

* 用户应用程序: 字处理、浏览器或者用户自编程的各种应用程序
* 操作系统服务: 向用户所提供的服务被看作是操作系统的部分功能的程序，如shell命令解释等
* 操作系统内核: 对硬件资源的抽象和访问调度
* 硬件系统

**Linux kernel 主要用途就是为了与硬件进行交互，实现对硬件部件的编程控制和接口操作，调度对硬件资源的访问，并为计算机上的用户程序提供一个高级的执行环境和对硬件的虚拟接口**

## Linux内核模式

* 整体式的单内核模式
* 层次式的微内核模式

Linux0.11内核是单内核模式，其有点是代码结构紧凑、执行速度快，不足主要是层次结构不强
> 在单内核模式系统中，操作系统所提供的服务流程：应用主程序使用指定的参数执行系统调用指令，使CPU从用户态切换到内核态，然后操作系统更具具体的参数调用特定的系统调用程序。在完成应用程序所要求的服务后，操作系统从内核态又切换回用户态，返回到应用程序中继续执行后面的指令

**单内核可以粗略的分为三个层次**
* 调用服务的主程序;
* 执行系统调用的服务层;
* 系统调用的底层函数.

## Linux内核系统体系结构

* 进程调度
 - 控制进程对CPU资源的使用
* 内存管理 
 - 确保所有进程可以安全地共享机器主存区
 - 支持虚拟内存管理，使得Linux支持进程使用比实际内存空间更多;
 - 利用文件系统把暂时不用的内存数据块交换到外部存储设备中，需要时再换回来
* 文件系统
 - 支持对外部设备的驱动和存储
 - 虚拟文件系统通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件设备的不同细节，从而提供并支持多种文件系统格式
* 进程间通信
 - 多进程间的信息交换
* 网络接口
 - 提供对多种网络通信标准的访问并支持多中网络硬件

**所有模块都与进程调度有依赖关系，因为他们都需要依靠进程调度程序来挂起或者重新运行他们的进程**

除了依赖关系外，所有模块都依赖于内核通用资源：包括所有子系统都会调用的内存分配和回收函数、打印信息或出错函数，以及一些系统调试函数等

## Linux内核源码目录结构

单内核模式，各程序紧密联系，依赖和调用关系也非常密切

目录结构：
* boot        系统引导汇编程序
* fs          文件系统
* include     头文件(\*.h)
 - asm        与CPU体系结构相关的部分
 - linux      Linux内核专用部分
 - sys        系统数据结构部分
* init        内核初始化程序
* kernel      内核进程调度、信号处理、系统调用等程序
 - blk_drv    块设备驱动程序
 - chr_drv    字符设备驱动程序
 - math       数学协处理器仿真处理程序
* lib         内核库函数
* mm          内存管理程序
* tools       生成内核Image文件的工具程序
* Makefile    嵌套调用子目录makefile

### 引导启动程序boot

boot目录包含3个汇编文件，是内核中最先被编译的程序

主要功能：
* 计算机加电时引导内核启动
* 将内核代码加载到内存中
* 做一些进入32位保护模式前的系统初始化工作

文件：
* bootsect.s 
> 磁盘引导块程序，编译后会驻留在磁盘的第一个扇区(引导扇区，0磁道，0磁头，第一扇区)。在PC加电ROM BIOS自检后，将被BIOS加载到内存0x7C00处进行执行
* setup.s
> 用于读取机器的硬件配置参数，并把内核模块system移动到适当的内存位置处
* head.s
> 会被编译链接在system模块的最前部分，主要进行硬件设备的探测设置和内存管理页面的初始设置工作

### 文件系统fs

fs是文件系统实现程序的目录，包含17各C程序
* file_table.c   仅定义了一个文件句柄(描述符)结构数组
* ioctl.c        引用kernel/chr_dev/tty.c中函数，实现字符设备的io控制功能
* exec.c         主要包含一个执行程序函数do_execve()，他是所有exec函数簇中的主要函数
* fcntl.c        用于实现文件IO控制的系统调用函数
* read_write.c   用于实现文件读/写和定位三个系统调用函数
* stat.c         实现了两个获取文件状态的系统调用函数
* open.c         实现修改文件属性和创建与关闭文件的系统调用函数
* char_dev.c     包含字符设备读写函数rw_char()
* pipe.c         包含管道读写函数和创建管道的系统调用
* file_dev.c     包含基于i节点和描述符结构的文件读写函数
* namei.c        包括文件系统中目录名和文件名的操作函数和系统调用
* block_dev.c    包含块数据读写函数
* inode.c        包含针对文件系统i节点操作的函数
* truncate.c     程序用于在删除文件时释放文件所占用的设备数据空间
* bitmap.c       用于处理文件系统中i节点和逻辑数据块的位图
* super.c        包含对文件系统超级块的处理函数
* buffer.c       用于对内存高速缓冲区进行处理
>> ll_rw_block   是块设备的底层读函数，它不再fs目录中，而是kernel/blk_dev/ll_rw_block.c中块设备读写驱动函数
**文件系统对于块设备中数据读写，都需要通过高速缓冲区与块设备的驱动程序(ll_rw_block)来操作，文件系统程序集本身并不直接与块设备的驱动程序打交道**

   .------------.   .-------.        .-------.        .-------.
   | file_table |   | ioctl |        | exec  |\       | fcntl |
   '------------'   '-------'        '-|-----' \      '-------'
           .------------.              |        \         |
          /| read_write |\             |         \        |
         / '------------' \            |          \    .--v---.
        /      |   |       \           | .------.  \   | open |
       /       |   |        \          | | stat |\  \  '------'
   .--v-------.| .-v----. .--v-------. | '------' \  \    |
   | char_dev || | pipe | | file_dev | |    /      \ .v---v--.
   '----------'| '------' '----------'.--------------| namei |--->|
               |               |    | ||  /          '-------'    |
          .----v------.        |    v vv v               |        |
          | block_dev |        |  .-------.        .-----v----.   |
          '-----------'        |  | inode |------->| truncate |   |
                \              |  '-------'        '----------'   |
                 \             |   |   \            |/            |
                  \            |   |    \           |             |
                   \           |   |     \         /|             |
                    \          |   |      \       / |             |
                     \         |   |       \     /  |             |
                      \        |   |     .--v---v-. |             |
                       \       |   |     | bitmap | |             |
                        \      |   |     '--------' |             |
                         \     |   |             \  |             |
                          \    |   | .------------\-v             |
                           \   |   | |             \              |
                            v  v   v v              \             |
                           .--------.              .-v-----.      |
                           | buffer |              | super |<-----'
                           '--------'              '-------'
                               |
                         .-----v-------.
                         | ll_rw_block |
                         '-------------'

### 头文件主目录include

一共32个头文件，其中主目录下有13个，asm下有4个，linux下有10个，sys有5个
* a.out.h        a.out头文件，定义了a.out执行文件格式和一些宏
* const.h        常数符号头文件，目前仅定义了i节点中i_mode字段的各标志位
* ctype.h        字符类型头文件。定义了一些有关字符类型判断和转换的宏
* errno.h        错误号头文件。包括系统中各种出错号
* fcntl.h        文件控制头文件。用于文件及描述符的操作控制常数符号的定义
* signal.h       信号头文件。定义信号符号常量，信号结构及信号操作函数原型
* stdarg.h       标准参数头文件。以宏的形式定义变量参数列表。主要说明了一个类型 (va_list)和三个宏(va_start,va_arg和va_end)，用于vsprintf、vprintf、vfprintf函数
* stddef.h       标准定义头文件。定义了NULL，offsetof(TYPE, MEMBER)
* string.h       字符串头文件。主要定义了一些有关字符串操作的嵌入函数
* termios.h      终端输入输出的函数头文件。主要定义控制异步通信接口的终端接口
* time.h         时间类型头文件。其中最主要定义了tm结构和一些有关时间的函数原型
* unistd.h       Linux标准头文件。定义了各种符号常数和类型，并声明了各种函数。如定义了\_\_LIBARAY\_\_，还包括系统调用号和内嵌汇编\_syscall0()等
* utime.h        用户时间头文件。定义了访问和修改时间结构及utime()原型

include/asm下主要定义了一些与CPU体系相关的数据结构、宏等
* asm/io.h       io头文件。以宏的嵌入汇编程序形式定义对io端口操作的函数
* asm/memory.h   内存拷贝头文件。含有memcpy()嵌入式汇编宏函数
* asm/segment.h  段操作头文件。定义了有关段寄存器操作的嵌入式汇编函数
* asm/system.h   系统头文件。定义了设置或修改描述符/中断门等的嵌入式汇编宏

include/linux内核专用头文件

* linux/config.h 内核配置头文件。定义键盘语言和硬盘类型(HD_TYPE)可选项
* linux/fdreg.h  软驱头文件。含有软盘控制器参数的一些定义
* linux/fs.h     文件系统头文件。定义文件表结构(file, buffer_head, m_inode等)
* linux/hdreg.h  硬盘参数头文件。定义访问磁盘寄存器端口，状态码，分区表等信息
* linux/head.h   head头文件，定义了段描述符的简单结构和几个选择符常量
* linux/kernel.h 内核头文件。包含一些内核常用函数的原型定义。
* linux/mm.h     内存管理头文件。包含页面大小定义和一些页面释放函数原型
* linux/sched.h  调度程序头文件。定义了结构体task_struct、初始任务0的数据。
* linux/sys.h    系统调用头文件。包含72个系统调用C函数处理程序，以sys\_开头
* linux/tty.h    tty头文件，定义了有关tty_io，串行通信方面的参数、常数

include/sys系统专用数据结构

* sys/stat.h     文件状态头文件。包含文件或文件系统状态结构stat()和常量
* sys/times.h    定义了进程中运行时间结构tms以及times()函数原型
* sys/types.h    类型头文件。定义了基本的系统数据类型
* sys/utsname.h  系统名称结构头文件
* sys/wait.h     等待调用头文件。定义系统调用wait()和waitpid()及相关常数符号

### 内核初始化程序目录init

只有一个main.c。用于执行内核所有的初始化工作，然后移到用户模式创建新进程，并在控制台设备上运行shell程序
> 1. 根据内存大小对缓冲区内存容量进行分配，如果还设置了要使用虚拟盘，则在缓冲区内存后面也为它留下空间
> 2. 所有硬件初始化工作，包括人工创建的第一个任务(task 0)，并设置了中断允许标志
> 3. 在执行从内核态移到用户态后，系统第一次调用创建进程函数fork()，创建出一个用于运行init()的进程，在该子进程中，系统将设置控制台环境，并且再生成一个子进程用来运行shell程序

### 内核程序主目录kernel

linux/kernel目录中共包含12个代码和一个Makefile，调用关系复杂，因此就对大致功能进行分类

通用程序                  | 硬件中断程序 |  系统调用程序                | |调
schedule.c      |         | asm.s        |  system_call.s               | |用
panic.c         | mktime  |              |                              | |关
printk,vsprintf |         | traps.c      |  fork.c,sys.c,exit.c,signal.c| v系

* asm.s     用于处理系统硬件异常所引起的中断，对各硬件异常的实际处理程序则是在traps.c文件中，在各个中断处理过程中，将分别调用traps.c中相应的C函数
* exit.c    主要包括用于处理进程终止的系统调用。包括进程释放、会话终止和程序退出处理函数以及杀死进程、终止进程、挂起进程等系统调用函数
* fork.c    提供了sys_fork()系统调用中使用的find_empty_process()和copy_process()两个函数
* mktime.c  包含一个内核使用的时间函数mktime()，用于计算从1970/1/1起到开机当日的秒数，仅在init/main.c中被调用一次
* panic.c   包含一个显示内核出错信息显示函数printk()
* printk.c  包含内核专用信息显示函数printk()
* sched.c   包括有关调度的基本函数(sleep_on, wakeup, schedule等)以及一些简单的系统调用函数。
* signal.c  包括了有关信号处理的4个系统调用以及一个在对应的中断处理程序中处理信号的函数do_signal()
* sys.c     包括很多系统调用函数，其中还有不少没实现呢
* system_call.s  实现了linux系统调用(int 0x80)的接口处理过程，实际的处理过程则包含在各系统调用相应的C语言处理函数中，这些处理函数分布在整个linux内核代码中
* vsprintf.c  实现了现在已经归入标准库函数中的字符串格式化函数

#### 块设备驱动程序子目录kernel/blk_dev

包含4个C和一个h文件，blk.h是为块设备程序专门使用的，所以与C文件放在一起

  .-------.   .-------------.
  | blk.h |   | ll_rw_blk.c |
  '-------'   '-------------'
                  /   |
                 /    |
           .----v-. .-v--------.
           | hd.c | | floppy.c |
           '------' '----------'

* blk.h    定义了3个C程序中共用的块设备结构和数据块请求结构
* hd.c     主要实现对硬盘数据块进行读写的底层驱动函数，主要是do_hd_request()
* floppy.c 主要实现了对软盘数据块的读写驱动函数，主要是do_fd_request()
* ll_rw_blk.c  实现了底层块设备数据读写函数ll_rw_block()，内核中所有其他程序都是通过调用该函数对块设备进行数据读写操作。该函数在 许多访问块设备数据的地方被调用，尤其是在高速缓冲区处理文件fs/buffer.c中

#### 字符设备驱动程序子目录 kernel/chr_dev

包含4个C和2各汇编文件。这些文件实现了对串口rs-232, tty, 键盘,和终端控制台设备的驱动

                   .----------.   .-------------.
                  /| tty_io.c |\  | tty_ioctl.c |
                 / '----------' \ '-------------'
                /    |     |     \
               /     |     |      \
              /      |     |       \
             /       |     |        \
            /        |     |         \
 .---------v..-------v-..--v--------..v-----------.
 | serial.c || rs_io.s || console.c || keyboard.S |
 '----------''---------''-----------''------------'

* tty_io.c    包含对tty字符设备读函数tty_read()和写函数tty_write()，另外还包括在串行中断处理过程中调用的C函数do_tty_interrupt()，该函数会在中断类型为读字符的处理中被调用
* console.c   主要包括控制台初始化程序和控制台写函数con_write()，用于被tty设备调用，还包括对显示器和键盘中断的初始化设置程序con_init()
* rs_io.s     用于实现两个串行接口的中断处理程序。该中断处理程序会根据从中断标识寄存器(端口0x3fa或者0x2fa)中取的的4种中断类型分别进行处理，并在处理中断类型为读字符的代码中调用do_tty_interrupt()
* serial.c    用于对异步串行通信芯片UART进行初始化操作，并设置两个通信端口的中断向量。另外还包括tty用于向串口输出的rs_write()函数
* tty_ioctl.c 实现了tty的io控制接口函数tty_ioctl()以及对termio(s)终端io结构的读写函数，并会在实现系统调用sys_ioctl()的fs/ioctl.c程序中被调用
* keyboard.S  主要实现了键盘中断处理过程keyboard_interrupt

#### 数学协处理器仿真和操作程序子目录kernel/math

只有一个C程序math_emulate.c。其中math_emulate()函数是中断int7的中断处理程序调用C函数。当机器中没有数学协处理器，而CPU又执行了协处理器的指令时，就会引发该中断。因此该中断就是用软件来仿真协处理器功能






